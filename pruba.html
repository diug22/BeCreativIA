<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Space Tunnel Loading</title>
  <style>
    body, html {margin:0; padding:0; overflow:hidden; background: radial-gradient(circle at center, #0f0f2a 0%, #00030f 90%); font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif; color:#e8f3ff;}
    #overlay {position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; pointer-events:none; z-index:10;}
    #loadingText {font-size:1.9rem; letter-spacing:1px; margin-bottom:6px; text-align:center; text-shadow:0 0 12px rgba(232,243,255,0.6); transition:transform .2s ease;}
    #barContainer {width:280px; height:6px; background:rgba(232,243,255,0.08); border-radius:3px; overflow:hidden;}
    #bar {width:0%; height:100%; background:linear-gradient(90deg,#8fbce6,#d8e9ff); border-radius:3px; transition:width .3s ease;}
    #content {position:absolute; inset:0; display:none; align-items:center; justify-content:center; font-size:2.8rem; z-index:5;}
    canvas {display:block;}
  </style>
</head>
<body>
  <div id="overlay">
    <div id="loadingText">Cargando... 0%</div>
    <div id="barContainer"><div id="bar"></div></div>
  </div>
  <div id="content">ðŸš€ Â¡Listo! Contenido principal aquÃ­.</div>
  <canvas id="c"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script>
    // === Setup ===
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x00030f, 0.0025);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0,0,0);
    window.addEventListener('resize', ()=>{renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();});

    // === ParÃ¡metros centrales ===
    const centerZ = -60;                 // Punto de destino base de los rayos
    const holeRadius = 6;             // radio vacÃ­o central donde no penetran los rayos
    const RAY_COUNT = 800;
    const rays = [];
    const rayMaterial = new THREE.MeshBasicMaterial({color:0xc0dff6, transparent:true, opacity:0.35, blending:THREE.AdditiveBlending, depthWrite:false});
    const maxDist = 160;
    const minDist = 30;
    const centerPoint = new THREE.Vector3(0,0,centerZ);

    // punto hasta donde deben llegar: antes de entrar en el hueco central
    function computeEndPoint(origin){
      const dirToCenter = new THREE.Vector3().subVectors(centerPoint, origin).normalize();
      // alejarse desde el centro en direcciÃ³n opuesta para que el extremo estÃ© a "holeRadius" de distancia
      return new THREE.Vector3().copy(centerPoint).addScaledVector(dirToCenter.clone().negate(), holeRadius);
    }

    function createRay(){
      // origen en esfera alrededor del centro
      const theta = Math.random()*Math.PI*2;
      const phi = Math.acos(2*Math.random()-1);
      const radius = Math.random()*(maxDist - minDist) + minDist;
      const x = Math.sin(phi)*Math.cos(theta)*radius;
      const y = Math.sin(phi)*Math.sin(theta)*radius;
      const z = Math.cos(phi)*radius;
      const origin = new THREE.Vector3(x, y, z + centerZ);
      // calcular punto final antes del hueco
      const endPoint = computeEndPoint(origin);
      const dir = new THREE.Vector3().subVectors(endPoint, origin).normalize();
      const length = origin.distanceTo(endPoint);
      const geometry = new THREE.CylinderGeometry(0.02, 0.02, length, 6, 1, true);
      const mesh = new THREE.Mesh(geometry, rayMaterial.clone());
      const mid = new THREE.Vector3().addVectors(origin, endPoint).multiplyScalar(0.5);
      mesh.position.copy(mid);
      mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().negate());
      const speed = 20 + Math.random()*15;
      rays.push({mesh, origin, dir, speed, length, endPoint});
      scene.add(mesh);
    }
      scene.add(mesh);
    }
    for(let i=0; i<RAY_COUNT; i++) createRay();

    // IluminaciÃ³n suave
    scene.add(new THREE.AmbientLight(0xffffff,0.35));
    const dirLight = new THREE.DirectionalLight(0xffffff,0.2);
    dirLight.position.set(2,3,4);
    scene.add(dirLight);

    // UI de carga
    const loadingText = document.getElementById('loadingText');
    const bar = document.getElementById('bar');
    const content = document.getElementById('content');
    let progress = 0, finishing = false;

    // AnimaciÃ³n
    let last = performance.now();
    function animate(now){
      requestAnimationFrame(animate);
      const delta = (now - last)/1000; last = now;

      rays.forEach((r,i)=>{
        r.origin.addScaledVector(r.dir, r.speed * delta);
        const dist = r.origin.distanceTo(r.endPoint);
        if(dist <= 1){
          scene.remove(r.mesh);
          rays.splice(i,1);
          createRay();
          return;
        }
        const mid = new THREE.Vector3().addVectors(r.origin, r.endPoint).multiplyScalar(0.5);
        r.mesh.position.copy(mid);
        const newLen = r.origin.distanceTo(r.endPoint);
        r.mesh.scale.set(1, newLen / r.length, 1);
        const opacity = Math.min(1, Math.max(0.1, dist / maxDist));
        r.mesh.material.opacity = 0.1 + (1 - opacity) * 0.5;
        
        r.mesh.scale.set(1, newLen / r.length, 1);
        const opacity = Math.min(1, Math.max(0.1, dist / maxDist));
        r.mesh.material.opacity = 0.1 + (1 - opacity) * 0.5;
      });

      // Simular progreso
      if(!finishing){
        progress += delta * 14;
        if(progress >= 100){ progress=100; beginFinish(); }
      }
      const disp = Math.floor(progress);
      loadingText.textContent = `Cargando... ${disp}%`;
      bar.style.width = disp + '%';
      loadingText.style.transform = (disp % 10 === 0) ? 'scale(1.02)' : 'scale(1)';

      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);

    function beginFinish(){
      finishing = true;
      const start = performance.now(); const duration = 1000;
      function step(now){
        const t = Math.min(1,(now-start)/duration);
        rays.forEach(r=>{ r.speed *= (1 - t*0.8); r.mesh.material.opacity *= (1 - t); });
        if(t >= 1){
          document.getElementById('overlay').style.transition='opacity .6s ease';
          document.getElementById('overlay').style.opacity='0';
          setTimeout(()=>{ content.style.display='flex'; content.style.opacity=0; content.style.transition='opacity .5s ease'; content.style.opacity=1; },250);
        } else requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }
  </script>
</body>
</html>
